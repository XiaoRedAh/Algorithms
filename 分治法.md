# 分治法

参考：算法导论和算法设计这两本书

1. Devide:将问题划分为多个子问题（相同问题的更小实例）
2. Conquer：递归地解决这些子问题
3. Combine：将自问题的解联合起来组建成原问题的解

## 如何分析复杂度



## 例题-最大子数组

来自算法导论第三版P68

问题描述
>在数组A[1...n]中找一个连续的子数组A[i...j],使得数组元素之和最大

### 解法一：分治法

找到数组的中点mid，那么任何连续的子数组A[i...j]都应该在这三个范围中的一个：

* 在A[low...mid]区间，low<=i<=j<=mid
* 在A[mid+1...high]区间，mid+1<=i<=j<=high
* 跨越中点，low<=i<=mid<=j<=high

前两种情况可以递归地去解出，因为它们是源问题的更小实例

但第三种情况必须单独解，因为它有必须“跨越中点”的限制，并非源问题的更小实例

最大子数组是三者的最大者

```c++
int findCross(int A[], int low, int mid, int high) {
	//终止条件
	if (low >= mid)return A[low];
	int sum = 0;
	int leftSum = INT_MIN;
	int rightSum = INT_MIN;
	//中点（包括中点）往左的最大子数组的值
	for (int i = mid; i > low; i--) {
		sum += A[i];
		leftSum = std::max(leftSum, sum);
	}
	//中点往右的最大子数组的值
	sum = 0;
	for (int i = mid + 1; i < high; i++) {
		sum += A[i];
		rightSum = std::max(rightSum, sum);
	}
	return leftSum + rightSum;
}
int findMaxSubArray(int A[], int low, int high) {
	//终止条件
	if (low >= high)return A[low];
	//int mid = (low + high) / 2;
	int mid = low + (high - low) / 2;
	//寻找中点左侧，右侧和跨越中点的最大子数组的值
	int leftMax = findMaxSubArray(A, low, mid);
	int rightMax = findMaxSubArray(A, mid + 1, high);
	int crossMax = findCross(A, low, mid, high);
	//返回三者中最大的那个
	if (leftMax >= rightMax && leftMax >= crossMax)return leftMax;
	else if (rightMax >= leftMax && rightMax >= crossMax)return rightMax;
	else return crossMax;
}
```

### 解法2：线性时间

### 解法3：动态规划

## 题目列表

### 多数元素

题目链接：https://leetcode.cn/problems/majority-element/

>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组**总是存在多数元素**。

这道题有多种解法：分治法，排序法，摩尔投票法，hashmap...，在这道题中，分治法不是最优的解法

注意：”给定的数组总是存在多数元素“这句话为题目下降了难度

#### 法一：分治法

divide：划分为左右两侧，求左侧数组的多数元素和右侧数组的多数元素，如果数相等，直接返回；若不等，返回个数多的那个

conquer：算多数元素在区间内的个数

```c++
class Solution {
public:
    int divide(vector<int>& nums, int left, int right){
        if(left==right)return nums[left];
        int mid = (left+right)>>1;
        int leftM = divide(nums, left, mid);
        int rightM = divide(nums, mid+1, right);
        if(leftM==rightM) return leftM;
        else{
            int leftCount = conquer(nums, leftM, left, mid);
            int rightCount = conquer(nums, rightM, mid+1, right);
            return (leftCount>rightCount)?leftM:rightM;
        }
    }
    int conquer(vector<int>& nums, int majorityE, int left, int right){
        int count = 0;
        for(int i=left;i<=right;i++)
            if(majorityE==nums[i])count++;
        return count;
    }
    int majorityElement(vector<int>& nums) {
        return divide(nums, 0, nums.size() - 1);
    }
};
```

#### 法二：摩尔投票法

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int count=0,candidate=0;
        for(int num :nums){
            if(count==0)candidate=num;
            count+=(candidate==num)?1:-1;
        }
        return candidate;
    }
};
```

### 快速幂

题目链接：https://leetcode.cn/problems/powx-n/

>实现x的n次方

对于x的n次方：
* n为偶数：x^n^ = x^n/2^ * x^n/2^
* n为奇数：x^n^ = x^(n+1)/2^ * x^(n-1)/2^ = x^n/2^ * x^n/2^ * x

divide：将x^n^划分为更小的x^n/2^计算
conquer：根据n的奇偶，将算出的数合并

时间复杂度是O(log~2~n)

```c++
class Solution {
public:
    double pow(double x, long long n){
        if(n==0)return 1;
        double y = pow(x, n/2);
        if(n%2==0) return y*y;
        else return y*y*x;
    }
    double myPow(double x, long long n) {
        if(x==0||x==1)return x;
        if(n<0)return 1/pow(x, -n);
        else return pow(x, n);
    }
};
```

### 矩阵快速幂

题目链接：https://www.luogu.com.cn/problem/P3390

```c++

```

### 数组中第k个最大元素

题目链接：https://leetcode.cn/problems/kth-largest-element-in-an-array/

主要三种解法：

* 暴力（O(nlog~2~n)）：排序，返回对应位置元素
* 分治法(O(N))
* 优先队列(O(Nlog~2~k))

#### 法一：分治法

这个代码不是很对

```c++
class Solution {
public:
    int quickSelect(vector<int>& nums, int l, int r, int k){
        int index = partition(nums, l, r);
        if(index==nums.size()-k) return nums[index];
        else{
            if(index>nums.size()-k) return quickSelect(nums, l, index-1, k);
            else return quickSelect(nums, index+1, r, k);
        } 
    }
    int getPivot(vector<int>& nums,int l,int r) {
        int midPos = (l + r) / 2;
	    if (nums[l] > nums[midPos])swap(nums[l], nums[midPos]);
	    if (nums[r] > nums[midPos])swap(nums[midPos], nums[r]);
	    if (nums[l] > nums[r])swap(nums[l], nums[r]);
	    return nums[r];
    }
    int partition(vector<int>& nums, int l, int r){
        int pivot = getPivot(nums, l, r);
        int i = l-1;
        int j = r;
        while(1){
            while(nums[++i]<pivot){}
            while(nums[--j]<pivot){}
            if(i<j)swap(nums[i],nums[j]);
            else break;
        }
        swap(nums[i], nums[r]);
        return i;
    }
    int findKthLargest(vector<int>& nums, int k) {
        return quickSelect(nums, 0, nums.size()-1, k);
    }
};
```

#### 法二：优先队列

```c++

```

### 合并k个升序列表

题目链接：https://leetcode.cn/problems/merge-k-sorted-lists/

有两种主流解法：分治法和优先队列法，时间复杂度一样

#### 法一：分治法

```c++

```

#### 法二：优先队列

```c++

```

### 平面最近点对

加强版：https://www.luogu.com.cn/problem/P1429
加强加强版：https://www.luogu.com.cn/problem/P7883

