# 分治法

参考：算法导论和算法设计这两本书

1. Devide:将问题划分为多个子问题（相同问题的更小实例）
2. Conquer：递归地解决这些子问题
3. Combine：将自问题的解联合起来组建成原问题的解

## 如何分析复杂度

###

## 例子

### 最大子数组

来自算法导论第三版P68

问题描述
>在数组A[1...n]中找一个连续的子数组A[i...j],使得数组元素之和最大

#### 解法一：分治法

找到数组的中点mid，那么任何连续的子数组A[i...j]都应该在这三个范围中的一个：

* 在A[low...mid]区间，low<=i<=j<=mid
* 在A[mid+1...high]区间，mid+1<=i<=j<=high
* 跨越中点，low<=i<=mid<=j<=high

前两种情况可以递归地去解出，因为它们是源问题的更小实例

但第三种情况必须单独解，因为它有必须“跨越中点”的限制，并非源问题的更小实例

最大子数组是三者的最大者

```c++
int findCross(int A[], int low, int mid, int high) {
	//终止条件
	if (low >= mid)return A[low];
	int sum = 0;
	int leftSum = INT_MIN;
	int rightSum = INT_MIN;
	//中点（包括中点）往左的最大子数组的值
	for (int i = mid; i > low; i--) {
		sum += A[i];
		leftSum = std::max(leftSum, sum);
	}
	//中点往右的最大子数组的值
	sum = 0;
	for (int i = mid + 1; i < high; i++) {
		sum += A[i];
		rightSum = std::max(rightSum, sum);
	}
	return leftSum + rightSum;
}
int findMaxSubArray(int A[], int low, int high) {
	//终止条件
	if (low >= high)return A[low];
	//int mid = (low + high) / 2;
	int mid = low + (high - low) / 2;
	//寻找中点左侧，右侧和跨越中点的最大子数组的值
	int leftMax = findMaxSubArray(A, low, mid);
	int rightMax = findMaxSubArray(A, mid + 1, high);
	int crossMax = findCross(A, low, mid, high);
	//返回三者中最大的那个
	if (leftMax >= rightMax && leftMax >= crossMax)return leftMax;
	else if (rightMax >= leftMax && rightMax >= crossMax)return rightMax;
	else return crossMax;
}
```

#### 解法2：线性时间

#### 解法3：动态规划


