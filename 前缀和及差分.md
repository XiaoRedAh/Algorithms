# 前缀和

前缀和的作用：快速求出元素组中某区间段内的和

## 一维前缀和

### 公式推导

原数组A[N]，前缀和数组S[N]

S[j] = $\sum_1^j$A[j]，即s[i] = S[i-1] + A[i]

S[r]-S[l-1]可以算出区间[l, r]的和

### 例题

## 二维前缀和

### 公式推导

原数组A[][],前缀和数组S[][]

则有：S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + A[i][j]

S[x2][y2] - S[x1 - 1][y2] - S[x2][y1 - 1] + S[x1 - 1][y1 - 1]可以算出区间区间[x1,y1,x2,y2]的和

![](img/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E6%A0%BC%E5%BC%8F%E6%8E%A8%E5%AF%BCpng.png)

### 例题


# 差分

差分的作用：
* 在O(1)时间内对某个区间的每个元素加上常数C
* 然后在O(n)时间内对差分数组进行前缀和运算，就可以得到经过操作后的原数组A



## 一维差分

### 公式推导

原数组A[N]，构造差分数组B[N]，使得A[i] = B[i]+B[2]+....+B[i]

```
B[1] = A[1]
B[2] = A[2] - A[1]
B[3 ]= A[3] - A[2]
...
B[n] = A[n] - A[n-1]
```

则有B[i] = A[i] - A[i-1]，发现A[N]是B[N]的前缀和，B[N]是A[N]的差分

**核心操作**

把序列A的区间[L,R]的所有元素都加d，其差分序列B的变化为：B[L]+d，B[R+1]-d，其他位置不变。

这样就可以把原序列上的“区间操作”转化为差分序列上的“单点操作”进行计算，降低求解难度。

### 例题

CCF202003-2：http://118.190.20.162/view.page?gpid=T142

首先对于每一个计划，计算出应在哪个时间段内拿到核酸证明，使得该计划能成功通行。然后让该时间段上的通行数都加1

当遍历完所有通行计划后，对差分数组进行前缀和还原成操作过后的原始数组（A[i]表示在时刻 i 拿到核酸证明，可以使计划通行的数量）

利用数组下标直接得到询问的结果

```c++
#include<iostream>
using namespace std;
const int N = 4e5 + 10;//t+q最大为2e5+2e5
int b[N];//差分数组
//对区间[left,right]中的每一个元素+c
void insert(int left, int right, int c) {
	b[left] += c;
	b[right + 1] -= c;
}
int main() {
	ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
	int n, m, k;
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) {//对于每一个计划
		int t, c;
		cin >> t >> c;
		//确定符合通过条件的最早拿到核酸证明时间
		int left = t - c + 1;
		left = left > 0 ? left : 1;
		//确定符合通过条件的最晚拿到核酸证明时间
		int right = t;
		//在这个区间内拿到核酸证明的可通行数全部加1
		insert(left, right, 1);
	}
	//对差分数组做前缀和，还原原始数组
	for (int i = 1; i < N; i++)
		b[i] += b[i - 1];
	while (m--) {
		int s;
		cin >> s;
		//直接通过数组下标查
		cout << b[s + k] << "\n";
	}
	return 0;
}
```

## 二维差分

### 公式推导

### 例题