# 统一模板

以升序的数组进行讨论

![](img/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF.png)

采用第一种模板：左开右开区间，左右指针相邻时结束(l+1==r)

好处：

* l,u指针变化规律统一（都是移到mid），好记
* 可行区的指针最后一定会指向答案
* 开区间可以正确处理边界

# 二分查找

**可行区：满足条件的区域称为可行区**

例如：求最后一个<=5的数的下标，条件是<=5。显然，满足这个条件的区域是左侧区域，因此可行区在左侧，左指针指向答案

**满足条件，则答案指针移动到mid，否则另一侧指针移动到mid**

继续沿用上述例子：

* a[mid]<=5成立，说明满足条件，那么答案指针l=mid
* a[mid]<=5不成立，说明不满足条件，那么另一侧指针r=mid

****

例：数组a[i]={1,2,3,5,5,5,7,8}(i=1....8)

最大化查找：求最后一个<=5的数的下标

最小化查找：求第一个>=5的数的下标

**最大化查找：可行区在左侧，左指针指向答案**

返回答案：6

```c++
int find(int q) {
	int l = 0， r = n + 1;//左开右开区间
	while (l + 1 < r) {//结束条件是l+1=r
		int mid = l + r >> 1;
		if (a[mid] <= q)l = mid;//满足条件，移动答案指针
		else r = mid;
	}
	return l;//可行区在左侧，左指针指向答案
}
```

**最小化查找：可行区在右侧，右指针指向答案**

返回答案：4

```c++
int find(int q) {
	int l = 0， r = n + 1;//左开右开区间
	while (l + 1 < r) {//结束条件是l+1=r
		int mid = l + r >> 1;
		if (a[mid] >= q)r = mid;//满足条件，移动答案指针
		else l = mid;
	}
	return r;//可行区在右侧，右指针指向答案
}
```

****

如果是**浮点数二分**

* 结束条件改为 r - l>1e-5(具体是大于几，要依据答案要求的精度)
* mid也要是double类型，要用(l+r)/2,不能用>>1（移位操作只能用于整形）

**两个例题**

整数二分：https://www.luogu.com.cn/problem/P2249
浮点数二分：https://www.luogu.com.cn/problem/P1024

# 二分答案

与二分查找相对应的，二分答案的题型分为最大化答案和最小化答案

## 模板

![](img/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E6%9D%BF%E5%AD%90.png)

其实就是套用二分查找的模板，把查找条件改为一个check(int x)函数



**最大化答案**

套用最大化查找的板子

如果x在可行区（满足条件），则check()函数为真，答案指针l右移（l = mid）；否则check()函数为假，另一侧指针r左移（r = mid）

*check(int x)函数何时返回true？*

设条件为C

* y是x的增函数时：return y<=C
  由于另check()为true是要让左指针右移（让x变大），因此为true的时候，应当是y<=C的时候。这时让左指针右移使得讨论的x变大，y增加。
* y是x的减函数时：return y>=C
  由于另check()为true是要让左指针右移（让x变大），因此为true的时候，应当是y>=C的时候。这时让左指针右移使得讨论的x变大，y减小。

```c++
bool check(int x) {
	...//计算y
	return y <= C;//当y是x的增函数时
	return y >= C;//当y是x的减函数时
}
int find() {
	int l = 下界 -1, r = 上界 + 1;
	while (l + 1 < r) {
		int mid = l + r >> 1;
		if (check(mid))l = mid;
		else r = mid;
	}
	return l;
}
```

**最小化答案**

套用最小化查找的板子

如果x在可行区（满足条件），则check()函数为真，答案指针r左移（r = mid）；否则check()函数为假，另一侧指针l右移（l = mid）

*check(int x)函数何时返回true？*

设条件为C

* y是x的增函数时：return y>=C
  由于另check()为true是要让右指针左移（让x变小），因此为true的时候，应当是y>=C的时候。这时让右指针左移使得讨论的x变小，y减小。
* y是x的减函数时：return y<=C
  由于另check()为true是要让右指针左移（让x变小），因此为true的时候，应当是y<=C的时候。这时让右指针左移使得讨论的x变小，y增大。

```c++
bool check(int x) {
	...//计算y
	return y >= C;//当y是x的增函数时
	return y <= C;//当y是x的减函数时
}
int find() {
	int l = 下界 -1, r = 上界 + 1;
	while (l + 1 < r) {
		int mid = l + r >> 1;
		if (check(mid))r = mid;
		else l = mid;
	}
	return r;
}
```

## 题目列表

### 垦田计划

题目链接：http://118.190.20.162/view.page?gpid=T164

题解：在CCF前三题做题记录里有

### 木材加工

题目链接：https://www.luogu.com.cn/problem/P2440

最大化，减函数

```c++
#include<iostream>
using namespace std;
int L[100005];
int k;
/*
求切割段长的最大值-->切割段长就是x，需要二分x最大化找答案
那么切的总段数就是y

切割成k段长度相等的小木头蕴含的不等式：总段数y>=k
段数y随着段长的增加而减少（减函数），计算公式为：y=L[i]/x, i=0...n
综上，可行区在左侧

此题的x，y的函数关系是离散函数，有以下两个特点：
1、x取连续的整数，y的值可能不变
2、x取连续的整数，y的值可能是跃变的
因此y的条件不一定是取等号的时候，x有最值，而是满足在这范围内。
*/
bool check(int x) {
	int sumK = 0;
	for (int Li : L)
		sumK += Li / x;
	return sumK >= k;
}
int main() {
	ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
	int n;
	int maxL = 0;
	cin >> n >> k;
	for (int i = 0; i < n; i++) {
		cin >> L[i];
		maxL = max(maxL, L[i]);
	}
	int l = 0, r = maxL + 1;
	while (l + 1 < r) {
		int mid = (l + r )>> 1;
		if (check(mid))l = mid;
		else r = mid;
	}
	cout << l;
	return 0;
}
```

### 跳石头

题目链接：https://www.luogu.com.cn/problem/P2678

最大化，增函数

```c++
#include<iostream>
using namespace std;
int s[500005];
/*
求最短跳跃距离的最大值，将它设为x
y：移走岩石的块数，条件是y<=M

二分枚举x，对于某个x：移走一定的石头，剩余石头的间距应当>=x
如何移走岩石（贪心）：
	从头开始跳，若下一跳距离<x,就把下一跳岩石移走，直到下一跳距离>=x才跳过去
	特别的：如果最后一块石头距离终点<x,则移走的是最后一块石头

最短跳跃距离越大，说明移走的次数越多（增函数）

对x进行最大化二分：看在y<=M的条件下，能否满足x
*/
int L, N, M;
bool check(int x) {
	int last = 0;//上一跳的石头下标（起点是0，终点是N+1）
	int move = 0;//记录移走石头的块数
	int i = 0;
	for (int i = 1; i <= N + 1; i++) {
		if (s[i] - s[last] < x)move++;//移走石头，起跳点不变
		else last = i;//不移动石头，继续往下跳
	}
	return move <= M;
}
int main() {
	ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
	cin >> L >> N >> M;
	for (int i = 1; i <= N; i++)
		cin >> s[i];
	s[N + 1] = L;
	int l = 0, r = L + 1;
	while (l + 1 < r) {
		int mid = (l + r) >> 1;
		if (check(mid))l = mid;
		else r = mid;
	}
	cout << l;
	return 0;
}
```

### 聪明的质检员

题目链接：https://www.luogu.com.cn/problem/P1314

### 借教室

题目链接：https://www.luogu.com.cn/problem/P1083

### 刺杀大使

题目链接：https://www.luogu.com.cn/problem/P1902

### 银行贷款

题目链接：https://www.luogu.com.cn/problem/P1163

## 小结

做二分答案题目思考方式：

1. 在脑海里要有一个函数意识：x和y
2. 先确定x：x就是题目需要的答案，对x进行二分枚举。再根据题目要求确定这是一道最小化答案还是最大化答案，确定总体模板。
3. 然后确定y，需要分析两方面：
   * x和y的函数关系：如何根据x求y，是增/减函数
   * 题目中对y的限制
4. 定义check()函数返回值的判断表达式，考虑以下三方面
   * 最大/小化答案
   * 函数关系增减性
   * y的限制
